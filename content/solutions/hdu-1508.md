+++
title = "[DP][ACM2004] Alphacode"
weight = 1
order = 1
date = 2020-02-04
#insert_anchor_links = "right"

[taxonomies]
tags = ["solutions"]
+++

[题目](https://vjudge.net/problem/HDU-1508)
[题目](https://vjudge.net/problem/SPOJ-ACODE)

题意：
给一串字符串形式的数字密文，
按照字母字典序反解有多少种可能的解

令$f(i)$为字符串前$i$个数字可能的解，则考虑这么几个条件：
1. $a_{i} \ne 0$
2. $a_{i-1}a_{i} \in [10, 26]$

- 首先将$f[i]$置0
- 如果满足条件1，则当前字符可以单独译码，即$f[i]+=f[i-1]$
- 如果满足条件2，则当前字符和前一字符可以组成一个有效码，即$f[i]+=f[i-2]$

注意：实现时前面加了个哨兵0，方便-2的时候不越界

```python
def main():
    code = input().strip()
    if code == '0':
        return
    code = '0' + code
    n = len(code)
    f = [0 for i in range(n)]
    f[0] = 1
    f[1] = 1

    for i in range(2, n):
        if code[i] != '0':
            f[i] += f[i-1]
        val = int(code[i-1:i+1])
        if val >= 10 and val <= 26:
            f[i] += f[i-2]

    print(f[n-1])


if __name__ == "__main__":
    while True:
        try:
            main()
        except EOFError:
            break
```
