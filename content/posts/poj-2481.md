+++
title = "[BIT][POJ2481] Cows"
weight = 1
order = 1
date = 2020-02-05
#insert_anchor_links = "right"

[taxonomies]
tags = ["algorithm"]
+++

[题目](https://vjudge.net/problem/POJ-2481)

[昨天研究了下数状数组](@/posts/fenwick-tree.md)，妙啊！治好了我的天气性抑郁。

这个题的意思就是先给一个规则确定牛之间的强弱关系，
然后求比某个牛更强的牛的数量。

可惜这个强弱关系没有传递性，
排序一次后不能直接得到结果。
但是排序可以确定$s$和$e$其中一个之间的大小关系，
然后另一个变量使用树状数组解决。

这里采用按照$e$的降序，若$e$相等则按照$s$的升序排序。
其实反过来按照$s$的升序，若$s$相等则按照$e$的降序排列也是可以的。
只不过第一种在后面比较的时候只需对每一个牛找到排在其前面且$s' \in [0, s]$的牛有多少即可，
反过来排序就变成了$e' \in [e, e_{max}]$，处理起来要麻烦一点。

一直在说树状数组，网上的题解也一直在说树状数组，
但到底里面存的是什么东西却没人说。
知道树状数组的特点就是获取前缀和相当容易，
那么处理过程中在数组中存放当前位置之前每一个$s$值对应了多少头牛。
求比给定$s$值小的牛有多少，其实就是$s$的前缀和。
这里的处理过程中保证了数组中存放的$s$值都是属于排在当前牛之前的牛。

再理一下，首先对牛排序，
排序后可以保证可能比$cow_i$更强壮的牛都排在其之前。
那么到底如何确定这些牛中有多少比$cow_i$强壮呢，
读取数组中$cow_i.s$的前缀和即可。
最后更新数组，将$cow_i.s$对应的数+1.
如此循环处理所有的牛。

注意这里的边界情况，
考虑三头牛$A=B>C$：
计算$B$时要排除$A$带来的重复，
但是计算$C$时$A，B$都要算进去。


```c++
#include <algorithm>
#include <iostream>
#include <vector>
using namespace std;

struct Node {
    Node(int s, int e, int i) : s(s), e(e), i(i) {}
    int s, e, i;
    bool operator<(Node const &other) const {
        return e > other.e || (e == other.e && s < other.s);
    }
    bool operator==(Node const &other) const {
        return e == other.e && s == other.s;
    }
    bool operator!=(Node const &other) const { return !(*this == other); }
};

struct Solution {
    int n, maxidx;
    vector<Node> cow;
    vector<int> tree;
    vector<int> res;

    int lowbit(int x) { return x & -x; }
    void update(int idx, int delta) {
        while (idx <= maxidx) {
            tree[idx] += delta;
            idx += lowbit(idx);
        }
    }
    int sum(int idx) {
        int sum = 0;
        while (idx > 0) {
            sum += tree[idx];
            idx -= lowbit(idx);
        }
        return sum;
    }

    Solution(int n) : n(n), maxidx(0), cow(), tree(), res() {
        for (int s, e, i = 0; i < n; ++i) {
            cin >> s >> e;
            s += 1;
            e += 1;
            cow.push_back(Node(s, e, i));
            maxidx = max(maxidx, s);
        }
        tree.resize(maxidx + 1);
        res.resize(n);
    }
    void solve() {
        sort(cow.begin(), cow.end());
        Node *prev = &cow.back();
        int cnt = 0;
        for (int i = 0; i < n; ++i) {
            Node *cur = &cow[i];
            if (*prev == *cur) {
                cnt += 1;
            } else {
                cnt = 0;
            }
            res[cur->i] = sum(cur->s) - cnt;
            update(cur->s, +1);
            prev = cur;
        }
        for (int i = 0; i < n; ++i) {
            cout << res[i] << " ";
        }
        cout << endl;
    }
};

int main() {
    ios::sync_with_stdio(false);
    cin.tie(NULL);
    while (true) {
        int n;
        cin >> n;
        if (n == 0) {
            break;
        } else {
            Solution(n).solve();
        }
    }
    return 0;
}
```